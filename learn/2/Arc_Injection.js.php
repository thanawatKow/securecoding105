<html>
<meta charset="utf-8"> 
</html>
<link type="text/css" rel="stylesheet" href="css\stacksmashing\layout_stack.css">
<table width="100%" border="0" colspan="0">
  <tr>
    <td width="40" height="36"><img src="../../images/1.jpg"  width="37" height="35"  alt=""/></td>
    <td width="988"><strong>Arc Injection</strong></td>
    <td width="3" rowspan="3">&nbsp;</td>
  </tr>
  <tr>
    <td height="52" colspan="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arc Injection คือ การเปลี่ยนค่า return address ให้กลายเป็นฟังก์ชัน system พร้อมกับระบุค่าอาร์กิวเมนต์ของฟังก์ชันให้เป็นบัฟเฟอร์ที่ใส่เข้าไป ทำให้แฮกเกอร์สามารถเรียกคำสั่งอะไรก็ได้ ตามต้องการในเครื่องของเหยื่อการทำ Arc Injection อาจจะเป็นการใช้โค้ดของเหยื่อเอง เช่น ใส่ข้อมูลจนล้นเพื่อไปเปลี่ยนตัวแปรอื่นๆ แต่หากเป็นการเปลี่ยนข้อมูลเพื่อเรียกไลบรารี มักเรียกกันว่าการโจมตีแบบ return-to-libc
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;โปรแกรม 2.7 มีโปรแกรมที่จะมีความเสี่ยงต่อการเกิดบัฟเฟอร์ล้นได้  ข้อมูลที่จัดมาให้สำหรับผู้ใช้ในการป้อนข้อมูลของผู้ใช้จะถูกคัดลอกไปยังอักขระที่ array ในบรรทัดที่ 4 โดยใช้คำสั่ง memcpy ()  มีbuffer overflowสามารถเกิดขึ้นได้หากผู้ใช้ ป้อนข้อมูลจะมีขนาดใหญ่กว่าของ buffer  รูป 2.3 ( a ) จะแสดงเนื้อหา stack ก่อนการทำงานฟังก์ชัน get_buff()  stack จะประกอบด้วย local variable buff แล้วตามด้วยตัวชี้ และ return กลับมาที่แอดเดรสของ eip  สำหรับ main( )  ด้านล่างนี้เป็นจริงสำหรับ stack frame ซึ่งก็คือ main() (อ้างอิงโดยจัดเก็บ frame pointer ) 
    </td>
  </tr>
  <tr>
    <td height="16" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td colspan="2">
    <div id="img1" align="center"><img src="../../images/3.png"></div>
    <div id="content-img1" align="center"></div></td>
    <td height="149">&nbsp;</td>
  </tr>

  <tr>
    <td colspan="2">

          <p>
      <div id="img2" align="center"><img src="../../images/4.png"></div>
         <div id="content-img2" align="center">รูป 2.3 Program stack overwritten by binary exploit</div>
      
    </td>
    <tr>
      <td colspan="2"><p>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3( b )  จะแสดงเนื้อหาสแตกหลังจากที่ผู้โจมตีจะ overflow  เขียนทับเนื้อหาของ stack ได้  ในส่วนนี้ของ stack  ยังได้รับการเขียนทับโดย overflow ได้ผู้โจมตีอาจจะสามารถวางข้อมูล buffer ที่แท้จริงแต่ในตัวอย่างนี้เราจะถือว่า buffer ที่จะถูกเขียนทับด้วยการเติมตัวอักษร  ตัวชี้ของเฟรมสำหรับ main() ถูกเขียนทับด้วย frame pointer สำหรับ frame  ทั้งหมดนี้จะทำให้ frame ของผู้โจมตีจะเป็นส่วนหนึ่งของการ exploit ได้  เมื่อใช้ exploit ฟังก์ชัน get_buff()  ส่งค่ากลับมาให้ซึ่งจะดำเนินการอย่างใดอย่างหนึ่งในสองรูปแบบที่เทียบเท่ากับของ frame ใช้ตัวชี้กลับไปตามลำดับที่แสดงไว้ในรูป 2.3 ( C )  โดยไม่คำนึงว่าผู้ใช้ใดที่มีการใช้ฟอร์ม , frame pointer ( ตอนนี้ที่ชี้ไปยังframeที่ 2 ) จะถูกย้ายไปในตัวชี้stack  การควบคุมการส่งคืนไปยังแอดเดรสบน stack ซึ่งได้รับการเขียนทับด้วยแอดเดรสของฟังก์ชันที่กำหนดเอง ฟังก์ชันนี้จะถูกเรียกใช้และส่งผ่านอาร์กิวเมนต์ที่ติดตั้งไว้บน stack  ผู้โจมตีจะต้องระบุหมายเลขที่เหมาะสมและชนิดของอาร์กิวเมนต์จะถูกเรียกใช้โดยถือว่าทำงานได้  ในรูป 2.3 ( b ) เราจะสันนิษฐานได้ว่าจะยอมรับตัวชี้ไปยังฟังก์ชันเป็น string  ( ตัวอย่างเช่น " system () ” )  เนื่องจากเนื้อหาจริงของ string ยังจำเป็นต้องได้รับการจัดหาให้มี string ที่วางอยู่บน stack ของอาร์กิวเมนต์ให้กับฟังก์ชันการใช้งานจริงได้ 
     <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;เมื่อ f ( ) จะส่งกลับให้ พร้อมกับ pop  stack eip ที่จัดเก็บและการควบคุมการถ่ายโอนไปยังแอดเดรสนี้แล้ว  ในกรณีนี้ได้ถูกเขียนทับด้วย eip แอดเดรสของกลับไปตามลำดับที่แสดงไว้ในรูป 2.3 ( c)  ซีเควนซ์นี้โดยปกติจะเป็นคำแนะนำที่สร้างขึ้นสำหรับการกลับไปยังฟังก์ชันที่เกิด ช่องโหว่ได้แต่ก็อาจจะปรากฏขึ้นที่ใดก็ได้ในส่วนของรหัสสำหรับการทำงานซึ่งลำดับที่ส่งกลับจะกำหนดตัวชี้เฟรม ( ตอนนี้ที่ชี้ไปยัง frame ที่ 3 ) ตัวชี้ของ stack และกลับไปที่การควบคุมที่กำหนดเองในครั้งถัดไปที่ฟังก์ชันที่จะถูกเรียก ( ในกรณีนี้คือ g () ) ผู้โจมตีจะสามารถทำซ้ำตามลำดับนี้ตามที่จำเป็นในการเรียกใช้ลำดับฟังก์ชันการดำเนินการเพื่อให้บรรลุเป้าหมายที่ใช้ประโยชน์ได้  ผู้โจมตีจะสามารถผลิตซ้ำเนื้อหา frame ต้นฉบับที่ซ้อนกันไปส่งคืนการควบคุมไปยัง main () หลังจากที่มีข้อบกพร่องของการทำงาน 
         <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ผู้โจมตีอาจชอบ arc injection เพื่อ injection รหัสผ่านไปได้ด้วยเหตุผลหลายประการ  เนื่องจาก arc injection ใช้รหัสที่มีอยู่แล้วในหน่วยความจำในระบบเป้าหมายที่ผู้โจมตีจะเป็นเพียงแค่ต้องให้ที่อยู่ของฟังก์ชันและอาร์กิวเมนต์สำหรับการโจมตีที่ประสบความสำเร็จ  เขตคลุมสัญญาณสำหรับประเภทนี้ของการโจมตีที่มีขนาดเล็กลงได้อย่างมากและอาจจะใช้เพื่อหาประโยชน์จากความบกพร่องที่ไม่สามารถใช้ในการจู่โจมได้โดยใช้เทคนิคการ injection รหัส  arc injection เป็นการโจมตีที่มีการใช้ข้อมูลที่ไม่สามารถแก้ไขได้โดยการทำให้ส่วนของหน่วยความจำ ( เช่น stack ) nonexecutable ได้ 
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ฟังก์ชันการเรียกเข้าด้วยกันได้อย่างหลากหลายด้วยการทำให้การโจมตีที่มีประสิทธิภาพมากยิ่งขึ้น  การรักษาความปลอดภัยเครื่องตั้งโปรแกรมที่คำนึงถึงความคุ้มค่าเป็นหลักตัวอย่างเช่นอาจจะทำตามหลักการให้สิทธิ์น้อยที่สุด และรายการดรอปดาวน์ Saltzer เมื่อไม่จำเป็นต้องใช้สิทธิ์  โดยการใช้ฟังก์ชันต่างๆได้อย่างหลากหลายด้วยการเรียกเข้าด้วยกัน , ข้อบกพร่องอาจให้สิทธิพิเศษในการรับสิทธิ์สำหรับตัวอย่างเช่นโดยการเรียกเพื่อติดต่อ setuid () ก่อนติดต่อ กับระบบ 
      </td>
    <tr>
    
   
    
    
   
      <td width="3"> </td>
  </tr>
</table>
